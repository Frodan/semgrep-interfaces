(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Type definitions for Semgrep CLI JSON output.
 *
 * This specifies for now only the JSON format of the 'scan' (default) command.
 *
 * This file has the _v1 suffix to explicitely represent the
 * version of this JSON format. If you need to extend this file, please
 * be careful because you may break consumers of this format (e.g., the
 * Semgrep playground or Semgrep App backend). See
 * https://atd.readthedocs.io/en/latest/atdgen-tutorial.html?highlight=json#smooth-protocol-upgrades
 * for more information on how to smoothly extend the types in this file.
 *
 * This file currently contains also the type definitions for semgrep-core's
 * JSON output, meant for the semgrep Python wrapper.
 * LATER: when ATD gets a module system, we can split this file in
 * different files (e.g., in Output_from_core.atd), but for now it's simpler
 * to have everything in one file.
 *
 * This file is translated into OCaml modules by atdgen:
 *  - Xxx_t: type definitions
 *  - Xxx_j: json serialization of those types
 *  Look for the corresponding Xxx_t.mli, Xxx_j.mli, etc.
 *  under dune's _build folder (where Xxx is Output_from_core).
 *
 * This file is also translated in Python modules by atdpy,
 * in jsonschema/openapi spec by atdcat, and in Typescript modules by
 * atdts.
 *
 * history:
 *  - the types in this file were originally inferred from JSON_report.ml for
 *    use by spacegrep when it was separate from semgrep-core. It's now also used
 *    in JSON_report.ml
 *
 * There are other very important form of outputs which are not specified here:
 *  - the schema for the generic AST dump is in AST_generic_v1.atd
 *  - The parsing stats of semgrep-core -parsing_stats -json have its own
 *    Parsing_stats.atd
 *
 * TODO:
 *   - see the TODO: and LATER: tags in this file
 *   - see the use of 'raw_json' type, try to transform as a real type when
 *     possible ('metadata:' can't for example, but the other like span: might)
 *)

(*****************************************************************************)
(* Imports *)
(*****************************************************************************)
(* LATER: hack because abstract below is not supported well yet by atdpy
 * NOTE: if you build manually datastructures with RawJson, you need
 * to call via RawJson(_Identity(stuff)).
 *)
<python text="
@dataclass
class _Identity:
    value: Any
    def to_json(self) -> Any:
        return self.value
class Abstract:
    @classmethod
    def from_json(cls, x: Any) -> Any:
        return _Identity(x)
">

(* escape hatch *)
type raw_json <ocaml module="Yojson.Safe" t="t"> = abstract
                                          
(*****************************************************************************)
(* Location *)
(*****************************************************************************)
type position
  <python decorator="dataclass(frozen=True, order=True)"> = {
  line: int; (* starts from 1 *)
  col: int; (* starts from 1 *)
  (* TODO: seems optional in some CLI output *)
  offset: int; (* byte position from the beginning of the file, starts at 0 *)
}

(* a.k.a range *)
type location
  <python decorator="dataclass(frozen=True)"> = {
  path: string (* source file *);
  start: position;
  end <ocaml name="end_">: position;
}

(*****************************************************************************)
(* Core Match result *)
(*****************************************************************************)

type rule_id <python decorator="dataclass(frozen=True)"> = string

type core_match
  <python decorator="dataclass(frozen=True)"> = {
  rule_id: rule_id;
  location: location;
  extra: core_match_extra;
}

(*
     name/value map of the matched metavariables.
     The leading '$' must be included in the metavariable name.

     TODO: semgrep-core always return a metavars, but dependency_aware Python code
     does not always generate a metavars (and match_extra is inherited
     in final_extra, hence the '?' below)
*)
type metavars = (string * metavar_value) list
               <json repr="object">
               <python repr="dict">

type core_match_extra
  <python decorator="dataclass(frozen=True)"> = {
  ?message: string option; (* rule.message (?) *)

  metavars: metavars;
}

type metavar_value
  <python decorator="dataclass(frozen=True)"> = {
  (* for certain metavariable like $...ARGS, 'end' may be equal to 'start'
   * to represent an empty metavariable value. The rest of the Python
   * code (message metavariable substitution and autofix) works
   * without change for empty ranges (when end = start).
   *)
  start: position;
  end <ocaml name="end_">: position;
  abstract_content: string; (* value? *)
  ?propagated_value: svalue_value option;

  (* The unique ID of a metavariable indicates the kind object that was
     captured for equality purposes. In the simplest case, this is only
     the name of the metavariable. In semgrep, it can additionally include
     a disambiguator. For example, consider this target code:

       let foo = 1;
       {
         let foo = 2;
       }

     The pattern '$X' would match the first 'foo' and the second 'foo'.
     In semgrep, these two 'foo's are identified as different variables,
     and this is done by setting the metavariable capture's unique ID to
     something like foo-1' and 'foo-2'. Even though their contents look
     identical, they're not the same thing.

     Spacegrep doesn't make this analysis, so these two captures will
     be considered identical, which is not as good.
  *)
  unique_id: unique_id;
}

type svalue_value
  <python decorator="dataclass(frozen=True)"> = {
  ?svalue_start: position option;
  ?svalue_end: position option;
  svalue_abstract_content: string; (* value? *)
}

(*
   This is just the variant for type=AST.
   In order to accommodate two record types into one variant, use
   the atdgen feature called a json adapter.
*)
type unique_id
  <python decorator="dataclass(frozen=True)"> = {
  (* pad: we should use a sum type here because it's either
     AST of md5sum | Id of sid * ... but that would require
     to update the python side, so for now I use optional
     fields, but really at least one of md5sum or sid should be a Some
   *)
  type_ <json name="type">: unique_id_type;
  (* AST case *)
  ?md5sum: string option;
  (* ID case *)
  ?sid: int option;
}

type unique_id_type
  <python decorator="dataclass(frozen=True)"> = [
  | ID <json name="id">
  | AST
]

(*****************************************************************************)
(* Core Errors *)
(*****************************************************************************)

(* See Semgrep_error_code.ml *)
type core_error
  <python decorator="dataclass(frozen=True)"> = {
  ?rule_id: rule_id option;
  (* LATER: use a variant. Define Semgrep_error_code.error_kind here *)
  error_type: string;
  severity: core_severity;
  location: location;
  message: string;
  ?details: string option;
  ?yaml_path: string list option;
}

type core_severity
  <python decorator="dataclass(frozen=True)"> = [
  | Error <json name="error">
  | Warning <json name="warning">
] <ocaml repr="classic">


type core_stats
  <python decorator="dataclass(frozen=True)"> = {
  okfiles: int;
  errorfiles: int;
}

(*****************************************************************************)
(* Skipping information *)
(*****************************************************************************)

(*
   If the 'rule_id' field is missing, the target is assumed to have
   been skipped for all the rules.
*)
type skipped_target
  <python decorator="dataclass(frozen=True)"> = {
  path: string;
  reason: skip_reason;
  details: string;
  ?rule_id: rule_id option;
}

(*
   A reason for skipping a target file or a pair (target, rule).
*)
type skip_reason
  <python decorator="dataclass(frozen=True)"> = [
  | Excluded_by_config <json name="excluded_by_config">
  | Wrong_language <json name="wrong_language">
  | Too_big <json name="too_big">
  | Minified <json name="minified">
  | Binary <json name="binary">
  | Irrelevant_rule <json name="irrelevant_rule">
  | Too_many_matches <json name="too_many_matches">
] <ocaml repr="classic">

type skipped_rule
  <python decorator="dataclass(frozen=True)"> = {
  rule_id: rule_id;
  details: string;
  (* position of the error in the rule file *)
  position: position;
}

(*****************************************************************************)
(* Core Profiling information *)
(*****************************************************************************)

type core_timing
  <python decorator="dataclass(frozen=True)"> = {
  targets: target_time list;

  (* List of rules received by core *)
  (* Needs to be separate to include rules read but not run on any target *)
  rules: rule_id list;
  ?rules_parse_time: float option; (* not used in spacegrep *)
}

(* later: could refactor [target_time] and [rule_times] to be equal
 * to cli_target_times *)
type target_time
  <python decorator="dataclass(frozen=True)"> = {
  path: string;
  (* parse and match time for each rule on target *)
  rule_times: rule_times list;
  (* run time for all rules on target *)
  run_time: float;
}

type rule_times
  <python decorator="dataclass(frozen=True)"> = {
  rule_id: rule_id;
  parse_time: float;
  match_time: float;
}

(*****************************************************************************)
(* Synthesizing from diffs (see locate_patched_functions in Synthesizing.mli) *)
(*****************************************************************************)

type cve_result
  <python decorator="dataclass(frozen=True)"> = {
   url: string;
   filename: string;
   funcnames: string list
}

type cve_results
  <python decorator="dataclass(frozen=True)"> = cve_result list

(*****************************************************************************)
(* Semgrep-core final output  *)
(*****************************************************************************)

type core_match_results
  <python decorator="dataclass(frozen=True)"> = {
  matches: core_match list;
  errors: core_error list;
  skipped_targets <json name="skipped">: skipped_target list;
  (* skipped_rules was introduced  in semgrep 0.86 *)
  ?skipped_rules: skipped_rule list option;
  stats: core_stats;
  (* LATER: rename timing *)
  ?time: core_timing option;
}


(*****************************************************************************)
(* CLI Errors (called SemgrepError in error.py) *)
(*****************************************************************************)

(* TODO: replace SemgrepCoreError in error.py or use CliError as component *)
(* TODO: try to make it as close as possible to 'error' above *)
(* LATER: maybe replace those dataclasses.replace() in error.py
 * with direct assign to the field? after all we didn't generate
 * a frozen dataclass here
 *)
type cli_error = {
  code: int;
  (* TODO: use a variant *)
  level: string;
  (* TODO: use a variant *)
  type_ <json name="type">: string;

  (* LATER: use a variant instead of all those ?xxx types *)

  ?rule_id: rule_id option;

  (* for most parsing errors those are set *)
  ?message: string option; (* contains error location *)
  ?path: string option;

  (* for invalid rules *)
  ?long_msg: string option;
  ?short_msg: string option;
  ?spans: raw_json option; (* TODO: see invalid_rule.json *)
  ?help: string option;
}

(*****************************************************************************)
(* Match result (called RuleMatch in rule_matches.py) *)
(*****************************************************************************)

(* TODO: replace RuleMatch in rule_matches.py or use CliMatch as component *)
(* TODO: try to make it as close as possible to 'match_' above *)
type cli_match = {
  check_id: rule_id;
  inherit location;
  extra: cli_match_extra;
}

(* TODO: use CliMatchExtra as component in RuleMatch *)
(* TODO: try to make it as close as possible to 'match_extra' above *)
type cli_match_extra = {
  (* TODO: inherit match_extra; but need ?metavars because of dependency_aware code *)
  ?metavars: metavars option;

  (* added by the CLI (see formatter/json.py) *)
  fingerprint: string;
  lines: string;

  (* fields coming from the rule *)
  message: string;
  metadata: raw_json;
  (* LATER: use a variant for severity *)
  severity: string;

  (* fields derived from the rule *)
  ?fix: string option;
  ?fix_regex: raw_json option;

  (* extra fields *)
  ?is_ignored: bool option;
  (* added by dependency_aware code *)
  ?dependency_match_only: bool option;
  ?dependency_matches: raw_json option;
}

(* TODO
type fix_regex = {
  regex: string;
  replacement: string;
}
 *)

(*****************************************************************************)
(* Semgrep CLI final output *)
(*****************************************************************************)

(* TODO: Note that the generated code for the type below is not yet used
 * in output.py but at least those types serve as a spec.
 *)
type cli_output = {
    errors: cli_error list;
    results: cli_match list;
    inherit cli_output_extra;
  }

type cli_output_extra = {
    paths: cli_paths;
    ?time: cli_timing option;
    (* seems unused, not in any results.json *)
    (* ?stats: cli_stats option; *)
    (* used only in TEXT format:
       ?color_output, per_finding_max_lines_limit, per_line_max_chars_limit
     *)
}

type cli_paths = {
    scanned: string list;
    (* LATER: either _comment or skipped:, use a variant *)
    ?_comment: string option;
    ?skipped: cli_skipped_target list option;
}

(* LATER: could merge with skipped_target above *)
type cli_skipped_target = {
    path: string;
    (* LATER: use a variant, reuse skip_reason above *)
    reason: string;
}

(* LATER: could merge with core_timing above
 * coupling: if you change the JSON schema below, you probably need to
 * also modify perf/run-benchmarks. Run locally  $ ./run-benchmarks --dummy --upload
 *)
type cli_timing = {
    rules: rule_id_dict list;
    rules_parse_time: float;
    (* LATER: define a cli_profiling_times with more precise keys *)
    profiling_times: (string * float) list <json repr="object"> <python repr="dict">;
    targets: cli_target_times list;
    total_bytes: int;
  }

(* LATER: should just use rule_id *)
type rule_id_dict = {
  id: rule_id;
}

(* LATER: get rid of profiler.dump_stats
type cli_profiling_times = {
   config_time: float;
   core_time: float;
   ignores_time: float;
   total_time: float;
}
*)

(* similar to the [target_time] and [rule_times] type above *)
type cli_target_times = {
    path: string;
    num_bytes: int;
    (* each elt in the list refers to a rule in cli_timing.rules *)
    match_times: float list;
    parse_times: float list;
    run_time: float;
}

(* TODO: the stats: field seems unused (could not find it in any e2e/.../results.json) *)
(*
type cli_stats = {
    (* (targets:, loc:, profiler:) *)
      xxx: int;
}
*)

(*****************************************************************************)
(* Semgrep App backend output *)
(*****************************************************************************)
